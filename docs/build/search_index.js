var documenterSearchIndex = {"docs":
[{"location":"Examples/Test1/#Capital-accumulation-problem","page":"Example 1","title":"Capital accumulation problem","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Consider the following capital accumulation problem, where a stochastic shock destroys are certain share of the production capital. The problem consists of the following variables:","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Production capital K_1(t) before the shock (first stage), K_2(ts) after the shock at time s (second stage).\nInvestment in production capital in the first, I_1(t), and second, I_2(ts), stage.\nConsumption c_1(t) and c_2(ts) in the first and second stage. Consumption is thereby the residual of production minus the cost for investment in production capital (which is assumed to be quadratic)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"beginaligned\r\nc_1(t) = K_1(t)^05 - I_1(t)^2 \r\nc_2(ts) = K_2(ts)^05 - I_2(ts)^2\r\nendaligned","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"The shock has an arrival rate of eta with the time horizon being scaled down to T=10. At the point of the shock, we assume a share gamma of production capital is being destroyed.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"The social planer now maximizes the aggregated consumption over the whole time horizon. The whole problem writes as follows:","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"beginaligned\r\nmax_I_1(t)I_2(ts) int_0^T e^rho tcdotleft Z_1(t)cdot Big K_1(t)^05 - I_1(t)^2Big + Q(t) right dt \r\nsthspace1cm dotK_1(t) = I_1(t) - delta K_1(t) qquad K_1(0) = K_1^0 \r\ndotZ_1(t) = - etacdot Z_1(t)                      qquad Z_1(0) = 1 \r\ndotK_2(ts) = I_2(ts) - delta K_2(ts)            qquad K_2(ss) = (1-gamma)cdot K_1(s) \r\ndotZ_2(ts) = 0                                     qquad Z_2(ss) = etacdot Z_1(s) \r\nQ(t) = int_0^t Z_2(ts)cdot Big K_2(ts)^05 - I_2(ts)^2Big ds\r\nendaligned","category":"page"},{"location":"Examples/Test1/#Solution-in-Julia","page":"Example 1","title":"Solution in Julia","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"To solve this problem with our Toolbox, we can use the main function TwoStageOptimisation.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> Results = TwoStageOptimisation(UserParameters = MyPara,\r\n                                ObjectiveIntegrand = U, \r\n                                AggregationFunction = Q,\r\n                                StateDynamic_1 = f1,\r\n                                StateDynamic_2 = f2, \r\n                                Shock = g,\r\n                                SalvageFunction_1=S1,\r\n                                SalvageFunction_2=S2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"But first we need to define the functions U, Q, f1, f2, g, S1 and S2 as well as the dictionary MyPara.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Let us start with the dictionary.","category":"page"},{"location":"Examples/Test1/#MyPara","page":"Example 1","title":"MyPara","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"The dictionary MyPara contains all relevant parameters of the model. We can initialize an empty dictionary by","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara = Dict()","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"MyPara contains information on","category":"page"},{"location":"Examples/Test1/#Model-specific-parameters","page":"Example 1","title":"Model specific parameters","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"like rho, eta and gamma in this example;","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"T\"] = 1\r\njulia> MyPara[\"rho\"] = 0.05\r\njulia> MyPara[\"delta\"] = 0.1\r\njulia> MyPara[\"eta\"] = 0.5\r\njulia> MyPara[\"gamma\"] = 0.2","category":"page"},{"location":"Examples/Test1/#Model-dimensions-of-controls-and-states","page":"Example 1","title":"Model dimensions of controls and states","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"nCon is the number of control variables in the first stage, nCon_dist is the number of control variables in the second stage. nStat and nStat_dist are the dimensions of state variables before and after the shock.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"nCon\"] = 1\r\njulia> MyPara[\"nCon_dist\"] = 1\r\njulia> MyPara[\"nStat\"] = 2\r\njulia> MyPara[\"nStat_dist\"] = 2","category":"page"},{"location":"Examples/Test1/#Control-boundaries-and-initial-state-values","page":"Example 1","title":"Control boundaries and initial state values","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"ConMin\"] = [0.0]\r\njulia> MyPara[\"Con_distMin\"] = [0.0]\r\njulia> MyPara[\"InitStat\"] = [0.1,1.0]","category":"page"},{"location":"Examples/Test1/#Algorithm-specifying-parameters","page":"Example 1","title":"Algorithm specifying parameters","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"hstep\"] = 0.05\r\njulia> MyPara[\"InitLineStep\"] = 1e-5\r\njulia> MyPara[\"UpperLineStep\"] = 1e-1\r\njulia> MyPara[\"hLowBound\"] = 0.01\r\njulia> MyPara[\"PlotResultsIntermediateFrequency\"] = 30","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Information on the parameters base values, which are used if not specified differently, can be found in the section Parameters, Variables, Settings","category":"page"},{"location":"Examples/Test1/#Model-functions","page":"Example 1","title":"Model functions","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Now we need to specify all the functions used in the model. Any function, that is not defined is assumed to be the zero-function.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"U(Con, Stat, t::Float64, Para::Dict) covers the utility function in the first stage (without the aggregated part Q(t) of the second stage). In our example this is ","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> U(Con, Stat, t::Float64, Para::Dict) = Stat[2]*(Stat[1]^0.5 - Con[1]^2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Q(Con,Stat, t::Float64,s::Float64, Para::Dict) contains the function which is integrated to obtain the second stage utiltiy.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> Q(Con,Stat, t::Float64,s::Float64, Para::Dict) = Stat[2]*(Stat[1]^0.5 - Con[1]^2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"f1(Con,Stat, t::Float64, Para::Dict) and f2(Con,Stat, t::Float64, s::Float64, Para::Dict) are the function of the right hand side of the state dynamics.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> f1(Con,Stat, t::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]*Stat[1],-Para[\"eta\"]*Stat[2]]\r\njulia> f2(Con,Stat, t::Float64, s::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]*Stat[1], 0]","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"g(Con,Stat,t::Float64, Para::Dict) describes the transition function between the state variables in the two stages.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> g(Con,Stat,t::Float64, Para::Dict) = [(1-Para[\"gamma\"])*Stat[1],Para[\"eta\"]*Stat[2]]","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"S1(Stat, Para::Dict) and S2(Stat_dist, Para::Dict) are the salvage-function in the first and second stage. Since we have no salvage value in our toy-example, we could omit them as entries in TwoStageOptimisation. However, we can also specifiy and enter them.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> S1(Stat, Para::Dict) = 0\r\njulia> S2(Stat_dist, Para::Dict) = 0","category":"page"},{"location":"Examples/Test1/#Solve-the-model","page":"Example 1","title":"Solve the model","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Finally we can solve the model. But first, we specify, that we want to give the initial guess for the control profiles to the algorithm","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"LoadInits\"] = true","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Now we define the profiles. We can pick the dimensions across time how big we like, the controls get interpolated in the solution process. Here we decided for 100 points. We define the control profiles as entries in the Results dictionary.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> Results = Dict()\r\njulia> Results[\"Con\"] = 4.0*ones(1,100,1)\r\njulia> Results[\"Con_dist\"] = 4.0*ones(100,100,1)\r\njulia> Results = TwoStageOptimisation(Results = Results,UserParameters = MyPara,\r\n                                ObjectiveIntegrand1 = U, \r\n                                AggregationIntegrand2 = Q,\r\n                                StateDynamic1 = f1,\r\n                                StateDynamic2 = f2, \r\n                                Shock12 = g,\r\n                                SalvageFunction1=S1,\r\n                                SalvageFunction2=S2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Finally we can save the results in location of choice and also plot the final results. We have the option to save the plots, and they are automatically save","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> SaveResults(Results,\"CapitalAccumulation\")\r\njulia> PlotResults(Results,SavePlot = true)","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"using TwoStageOptimalControl","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"U(Con, Stat, t::Float64, Para::Dict) = Stat[2] * ((Para[\"A\"] - Stat[1])Stat[1] - Para[\"b\"]Con[1] - Para[\"c\"]/2Con[1]^2) Q(Con,Stat, t::Float64,s::Float64, Para::Dict) = Stat[2] * ((Para[\"A\"] - Stat[1])Stat[1] - Para[\"b\"]Con[1] - Para[\"c\"]/2Con[1]^2)","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"f1(Con,Stat, t::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]Stat[1],                                         -Para[\"eta\"]Stat[2]] f2(Con,Stat, t::Float64, s::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]*Stat[1],                                                     0]","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"g(Con,Stat,t::Float64, Para::Dict) = [Stat[1],                                       Para[\"eta\"]*Stat[2]]","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"S1(Stat, Para::Dict) = 0 S2(Stat_dist, Para::Dict) = 0","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"MyPara = Dict() MyPara[\"A\"] = 60 MyPara[\"b\"] = 100 MyPara[\"c\"] = 10 MyPara[\"delta\"] = 0.1 MyPara[\"rho\"] = 0.1 MyPara[\"eta\"] = 0.05","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"MyPara[\"T\"] = 10 MyPara[\"hstep\"] = 0.5 MyPara[\"nCon\"] = 1 MyPara[\"nCondist\"] = 1 MyPara[\"nStat\"] = 2 MyPara[\"nStatdist\"] = 2 MyPara[\"InitStat\"] = [0.1,1.0] MyPara[\"ConMin\"] = [0.0] MyPara[\"Con_distMin\"] = [0.0]","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"MyPara[\"OptiType\"] = \"Newton-Raphson\" MyPara[\"ProbIndex\"] = 2","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"MyPara[\"InitLineStep\"] = 1e-5 MyPara[\"UpperLineStep\"] = 1e-2 MyPara[\"hLowBound\"] = 0.1 MyPara[\"PlotResultsIntermediateFrequency\"] = 150","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"MyPara[\"LoadInits\"] = true","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"Results = Dict() Results[\"Con\"] = 6.0ones(1,10,1) Results[\"Con_dist\"] = 6.0ones(10,10,1) Results = TwoStageOptimisation(Results = Results,UserParameters = MyPara,                                 ObjectiveIntegrand = U,                                  AggregationFunction = Q,                                 StateDynamic1 = f1,                                 StateDynamic2 = f2,                                  Shock = g,                                 SalvageFunction1=S1,                                 SalvageFunction2=S2)","category":"page"},{"location":"Examples/Test2/","page":"Example 2","title":"Example 2","text":"SaveResults(Results,\"test/CapitalAccumulationBenchmark\")","category":"page"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.integ4","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.integ4","page":"Auxiliary functions","title":"TwoStageOptimalControl.integ4","text":"integ4(n::Int64,h::Float64,F)\n\ninteg4 performs 4th order integration (Simpson-method) method for datavector `F` with `n` points with a distance of `h` between each of them.\nIf n > 1 and F = 1, F will be interpreted as a constant function over the n points.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.integ2","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.integ2","page":"Auxiliary functions","title":"TwoStageOptimalControl.integ2","text":"integ2(n::Int64,h::Float64,F)\n\ninteg2 performs 2nd order integration (trapezoid) method for datavector `F` with `n` points with a distance of `h` between each of them.\nIf n > 1 and F = 1, F will be interpreted as a constant function over the n points.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.integ1","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.integ1","page":"Auxiliary functions","title":"TwoStageOptimalControl.integ1","text":"integ1(n::Int64,h::Float64,F)\n\ninteg1 performs 1st order left boundary integration method for datavector `F` with `n` points with a distance of `h` between each of them.\nIf n > 1 and F = 1, F will be interpreted as a constant function over the n points.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.CumInteg4","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.CumInteg4","page":"Auxiliary functions","title":"TwoStageOptimalControl.CumInteg4","text":"CumInteg4(n::Int64,h::Float64,F)\n\nCumInteg4 calculates the cumulative integrals ``\\int_0^t F(s)ds \\forall t\\in(0,T)`` of `F` using a 4th order integration method.\n`n` = number of datapoints,\n`h` = distance between datapoints.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.interp1","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.interp1","page":"Auxiliary functions","title":"TwoStageOptimalControl.interp1","text":"interp1(xpt,ypt;method = \"Linear\",extrapolation = Flat())\n\nOne dimensional interpolation using either linear interpolation or BSplines\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.interp2","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.interp2","page":"Auxiliary functions","title":"TwoStageOptimalControl.interp2","text":"interp2(xpt,ypt,zpt)\n\nTwo dimensional interpolation using BSplines\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.SavitskyGolaySmoothing","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.SavitskyGolaySmoothing","page":"Auxiliary functions","title":"TwoStageOptimalControl.SavitskyGolaySmoothing","text":"SavitskyGolaySmoothing(x::Vector, windowSize::Integer, polyOrder::Integer; deriv::Integer=0)\n\nSmooth a vector x using the Savitsky-Golay method\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.ParaAdjust","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.ParaAdjust","page":"Auxiliary functions","title":"TwoStageOptimalControl.ParaAdjust","text":"ParaAdjust(h_global::Float64,Para::Dict) --> VOID function\n\nParaAdjust adjust all relevant elements of the Parameter dictionary `Para` to the step-size `h_global`.\nNo Output as entries of `Para` get overwritten\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.LoadVariables","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.LoadVariables","page":"Auxiliary functions","title":"TwoStageOptimalControl.LoadVariables","text":"LoadVariables(Para,Results)\n\nLoad inital profiles for the control variables from the Results dictionary and use interpolation if necessary\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.ConInterpol","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.ConInterpol","page":"Auxiliary functions","title":"TwoStageOptimalControl.ConInterpol","text":"ConInterpol(Con_dist::Array{Float64,3},Con::Array{Float64,3},Para::Dict)\n\nGiven Controls `Con_dist` and `Con`, ConInterpol performs an interpolation of these fields to fit the passed Parameter dict `Para`.\n\nOutputs: New Controls 'Con_dist_new' and `Con_new`\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.ConSmooth","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.ConSmooth","page":"Auxiliary functions","title":"TwoStageOptimalControl.ConSmooth","text":"ConSmooth(Con::Array{Float64,3},Con_dist::Array{Float64,3},Para::Dict)\n\nSmooth the profiles of the control variables using a SavitskyGolaySmoother\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.GradSmooth","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.GradSmooth","page":"Auxiliary functions","title":"TwoStageOptimalControl.GradSmooth","text":"GradSmooth(dHam::Array{Float64,3},dHam_dist::Array{Float64,3},Para::Dict)\n\nSmooth the gradient by using the median value of a moving window.\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/#LineSearch","page":"LineSearch","title":"LineSearch","text":"","category":"section"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.LineSearch","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.LineSearch","page":"LineSearch","title":"TwoStageOptimalControl.LineSearch","text":"LineSearch(Con::Array{Float64,3}, Stat::Array{Float64,3}, Con_dist::Array{Float64,3},  Stat_dist::Array{Float64,3}, Stat_agg::Array{Float64,3}, \n                Dir_u::Array{Float64,3}, Dir_u_dist::Array{Float64,3}, ObjValue::Float64, Step, Para::Dict,\n                Con_new::Array{Float64,3}, Stat_new::Array{Float64,3}, Con_dist_new::Array{Float64,3}, Stat_dist_new::Array{Float64,3}, Stat_agg_new::Array{Float64,3},\n                Con_best::Array{Float64,3}, Stat_best::Array{Float64,3}, Con_dist_best::Array{Float64,3}, Stat_dist_best::Array{Float64,3}, Stat_agg_best::Array{Float64,3})\n\nSearches for an improvement along the gradient using a quadratic approximation for the objective function along the gradient.\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.Update","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.Update","page":"LineSearch","title":"TwoStageOptimalControl.Update","text":"Update(Con::Array{Float64,3},Con_dist::Array{Float64,3},Dir_u::Array{Float64,3},Dir_u_dist::Array{Float64,3},Step,Para::Dict,\n            Con_new::Array{Float64,3},Stat_new::Array{Float64,3},Con_dist_new::Array{Float64,3},Stat_dist_new::Array{Float64,3}, Stat_agg_new::Array{Float64,3})\n\nUpdate calculates the new values for Controls `Con_new`, States `Stat_new` and Objectiv value given start values for the Controls `Con`, the search direction `Dir_u` and the step-size in the direction `step`\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.AssignBest","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.AssignBest","page":"LineSearch","title":"TwoStageOptimalControl.AssignBest","text":"AssignBest(ObjValue::Float64,Con::Array{Float64,3},Stat::Array{Float64,3},Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3}, Stat_agg::Array{Float64,3}, \n                step, \n                Con_best::Array{Float64,3}, Stat_best::Array{Float64,3}, Con_dist_best::Array{Float64,3},  Stat_dist_best::Array{Float64,3},  Stat_agg_best::Array{Float64,3})\n\nAssign the current variables to the \"best\" variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.maxabsGradient","category":"page"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ObjectValue","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ObjectValue","page":"Model Functions","title":"TwoStageOptimalControl.ObjectValue","text":"ObjectValue( Con::Array{Float64,3}, Stat::Array{Float64,3}, Con_dist::Array{Float64,3}, Stat_dist::Array{Float64,3},  Stat_agg::Array{Float64,3}, Para::Dict )\n\nCalculate the aggregated objective value of the optimal control problem for the current solutions of control and state variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.Aggregate","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.Aggregate","page":"Model Functions","title":"TwoStageOptimalControl.Aggregate","text":"Aggregate(Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Stat_agg::Array{Float64,3},Para::Dict )\n\nCalculate the aggregated variables over all vintage in the second stage\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ShockTransition","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ShockTransition","page":"Model Functions","title":"TwoStageOptimalControl.ShockTransition","text":"ShockTransition(Con::Array{Float64,3},Stat::Array{Float64,3},Stat_dist::Array{Float64,3},Para::Dict )\n\nCalculate the starting values for all vintages given the state profiles of the first stage.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_ODE","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_ODE","page":"Model Functions","title":"TwoStageOptimalControl.f_ODE","text":"f_ODE( tt::Int64, Con::Array{Float64,3}, Stat::Array{Float64,3}, Dt::Array{Float64,1}, Para::Dict )\n\nRight hand side of the ODE for the state variables in the first stage at time index tt.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_ODE_interstep","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_ODE_interstep","page":"Model Functions","title":"TwoStageOptimalControl.f_ODE_interstep","text":"f_ODE_interstep( t::Float64, Con, Stat, Para::Dict)\n\nRight hand side of the ODE for the state variables in the first stage. Only used for the 4th order RK-method where the Control variables have to be interpolated.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_PDE","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_PDE","page":"Model Functions","title":"TwoStageOptimalControl.f_PDE","text":"f_PDE( tt::Int64,ss::Int64, Con_dist::Array{Float64,3}, Stat_dist::Array{Float64,3}, Dt::Array{Float64,1},Para::Dict )\n\nRight hand side of the PDE for the state variables in the second stage at time index tt and vintage ss.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_ODE_co","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_ODE_co","page":"Model Functions","title":"TwoStageOptimalControl.f_ODE_co","text":"f_ODE_co( tt::Int64,Con::Array{Float64,3},Stat::Array{Float64,3},CoStat::Array{Float64,3},CoStat_dist::Array{Float64,3},Dt::Array{Float64,1},Para::Dict )\n\nRight hand side of the PDE for the costate variables in the first stage at time index tt.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_PDE_co","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_PDE_co","page":"Model Functions","title":"TwoStageOptimalControl.f_PDE_co","text":"f_PDE_co( tt::Int64,ss::Int64,Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},CoStat_dist::Array{Float64,3},Dt::Array{Float64,1},Para::Dict )\n\nRight hand side of the PDE for the costate variables in the second stage at time index tt and vintage ss.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.Hamiltonian","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.Hamiltonian","page":"Model Functions","title":"TwoStageOptimalControl.Hamiltonian","text":"Hamiltonian(Con, Stat, CoStat, CoStat_dist, t::Float64, Para::Dict )\n\nDefinition of the Hamiltonian with all terms relevant for the calculations including first stage variables.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.Hamiltonian_dist","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.Hamiltonian_dist","page":"Model Functions","title":"TwoStageOptimalControl.Hamiltonian_dist","text":"Hamiltonian_dist(Con_dist, Stat_dist, CoStat_dist, t::Float64, s::Float64, Para::Dict )\n\nDefinition of the Hamiltonian with all terms relevant for the calculations including second stage variables.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.GradHamiltonian","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.GradHamiltonian","page":"Model Functions","title":"TwoStageOptimalControl.GradHamiltonian","text":"GradHamiltonian(Con::Array{Float64,3},Stat::Array{Float64,3},Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Stat_agg::Array{Float64,3},CoStat::Array{Float64,3},CoStat_dist::Array{Float64,3},dHam::Array{Float64,3},dHam_dist::Array{Float64,3},Para::Dict)\n\nCalculation of the gradient of the Hamiltonian for both stages.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.NewDirection","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.NewDirection","page":"Model Functions","title":"TwoStageOptimalControl.NewDirection","text":"NewDirection(Con::Array{Float64,3},Stat::Array{Float64,3},Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Stat_agg::Array{Float64,3},CoStat::Array{Float64,3},CoStat_dist::Array{Float64,3},dHam::Array{Float64,3},dHam_dist::Array{Float64,3},Para::Dict)\n\nAdjustment of the gradient of the Hamiltonian depending on the optimisation type chosen. Available types are:\n    - \"Gradient\"\n        Uses the gradient without adjustments\n    - \"ProbAdjust\"\n        Adjusts the gradient for the weighting of the vintage in the second stage and the survival probability in the first stage\n    - \"Newton-Raphson\"\n        Adjusts the gradient as described in the Newton-Raphson method using the Hessian of the Hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ConMapping","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ConMapping","page":"Model Functions","title":"TwoStageOptimalControl.ConMapping","text":"ConMapping( Con::Array{Float64,3}, Para )\n\nMap control variables in the first stage into the feasible region described by the lower and upper bounds of the controls.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ConMapping_dist","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ConMapping_dist","page":"Model Functions","title":"TwoStageOptimalControl.ConMapping_dist","text":"ConMapping_dist( Con_dist::Array{Float64,3}, ii, Para )\n\nMap control variables in the second stage into the feasible region described by the lower and upper bounds of the controls.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.EndConstraintCoStat","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.EndConstraintCoStat","page":"Model Functions","title":"TwoStageOptimalControl.EndConstraintCoStat","text":"EndConstraintCoStat(Stat::Array{Float64,3},CoStat::Array{Float64,3},Para::Dict)\n\nDefine the endconstraint for the first stage costate variables using the derivative of the salvage-function.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.EndConstraintCoStat_dist","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.EndConstraintCoStat_dist","page":"Model Functions","title":"TwoStageOptimalControl.EndConstraintCoStat_dist","text":"EndConstraintCoStat_dist(Stat_dist::Array{Float64,3},CoStat_dist::Array{Float64,3},Para::Dict)\n\nDefine the endconstraint for the second stage costate variables using the derivative of the salvage-function.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.AssignResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.AssignResults","page":"Results analysis","title":"TwoStageOptimalControl.AssignResults","text":"AssignResults(Results::Dict, Con::Array{Float64,3}, Stat::Array{Float64,3}, Con_dist::Array{Float64,3}, Stat_dist::Array{Float64,3}, Stat_agg::Array{Float64,3}, CoStat::Array{Float64,3}, CoStat_dist::Array{Float64,3}, dHam::Array{Float64,3}, dHam_dist::Array{Float64,3}, Para::Dict)\n\nAssign the control and state variables to the Results dictionary\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.PlotResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.PlotResults","page":"Results analysis","title":"TwoStageOptimalControl.PlotResults","text":"PlotResults(Results2::Dict;SavePlot=false,Display=true,sizeX=600,sizeY=400)\n\nBasic plots of all controls + gradient and state + costate variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.SaveResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.SaveResults","page":"Results analysis","title":"TwoStageOptimalControl.SaveResults","text":"SaveResults(Results::Dict,filepath)\n\nSave the Results Dictionary to filepath\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.LoadResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.LoadResults","page":"Results analysis","title":"TwoStageOptimalControl.LoadResults","text":"LoadResults(filepath)\n\nLoad the Results Dictionary from the filepath\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.state_PDE_solver","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.state_PDE_solver","page":"-","title":"TwoStageOptimalControl.state_PDE_solver","text":"state_PDE_solver(Con::Array{Float64,3},Stat::Array{Float64,3},Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Stat_agg::Array{Float64,3},Para::Dict)\n\nstate_PDE_solver solves the dynamic system of state equations with given initial conditions and control variables.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.HeunODE","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunODE","page":"-","title":"TwoStageOptimalControl.HeunODE","text":"HeunODE(Con::Array{Float64,3},Stat::Array{Float64,3},Para::Dict)\n\nHeunODEco solves the state dynamics in the first stage forward in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.RK4ODE","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.RK4ODE","page":"-","title":"TwoStageOptimalControl.RK4ODE","text":"RK4ODE(Con::Array{Float64,3},Stat::Array{Float64,3},Para::Dict)\n\nRK4ODE solves the state dynamics in the first stage forward in time using a 4th-order Runge-Kutta method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.HeunPDE","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunPDE","page":"-","title":"TwoStageOptimalControl.HeunPDE","text":"HeunPDE(jj,Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Para::Dict)\n\nHeunODEco solves the state dynamics for vintage jj in the second stage forward in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.costate_PDE_solver","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.costate_PDE_solver","page":"-","title":"TwoStageOptimalControl.costate_PDE_solver","text":"costate_PDE_solver(Con::Array{Float64,3},Stat::Array{Float64,3},Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Stat_agg::Array{Float64,3},\n                        CoStat::Array{Float64,3},CoStat_dist::Array{Float64,3},CoStat_agg::Array{Float64,3},Para::Dict)\n\ncostate_PDE_solver solves the dynamic system of co-state equations backwards with given endvalues for given controls and state variables.\nFor the special case of endconstraints for the STATE-variables, we use the FOC to derive the respective value of CO-STATE variable.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.HeunODEco","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunODEco","page":"-","title":"TwoStageOptimalControl.HeunODEco","text":"HeunODEco(Con::Array{Float64,3},Stat::Array{Float64,3},CoStat::Array{Float64,3},CoStat_dist::Array{Float64,3},Para::Dict)\n\nHeunODEco solves the costate dynamics in the first stage backwards in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"-","title":"-","text":"TwoStageOptimalControl.HeunPDEco","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunPDEco","page":"-","title":"TwoStageOptimalControl.HeunPDEco","text":"HeunPDEco(jj,Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},CoStat_dist::Array{Float64,3},Para::Dict)\n\nHeunPDEco solves the costate dynamic for vintage jj in the second stage backwards in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"#TwoStageOptimalControl","page":"Home","title":"TwoStageOptimalControl","text":"","category":"section"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"#Main-function-for-usage","page":"Home","title":"Main function for usage","text":"","category":"section"},{"location":"#Auxiliary-functions","page":"Home","title":"Auxiliary functions","text":"","category":"section"},{"location":"#LineSearch","page":"Home","title":"LineSearch","text":"","category":"section"},{"location":"#Model-Functions","page":"Home","title":"Model Functions","text":"","category":"section"},{"location":"#Parameters,-Variables-and-Settings","page":"Home","title":"Parameters, Variables & Settings","text":"","category":"section"},{"location":"#Analysis-of-Results","page":"Home","title":"Analysis of Results","text":"","category":"section"},{"location":"#State-solvers","page":"Home","title":"State solvers","text":"","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"link to Example 1","category":"page"},{"location":"Functions/MainFunction/#Main-Function","page":"Main Functions","title":"Main Function","text":"","category":"section"},{"location":"Functions/MainFunction/","page":"Main Functions","title":"Main Functions","text":"TwoStageOptimisation","category":"page"},{"location":"Functions/MainFunction/#TwoStageOptimalControl.TwoStageOptimisation","page":"Main Functions","title":"TwoStageOptimalControl.TwoStageOptimisation","text":"TwoStageOptimisation(;Results=Dict(),\n        UserParameters=Dict(),\n        ObjectiveIntegrand1 = (C1, S1, t::Float64, Para::Dict) -> 0,\n        AggregationIntegrand2 = (C2, S2, t::Float64,s::Float64, Para::Dict) -> 0,\n        StateDynamic1 = (C1, S1, t::Float64, Para::Dict) -> 0, \n        StateDynamic2 = (C2, S2, t::Float64, s::Float64, Para::Dict) -> 0, \n        Shock12 = (C1, S1, t::Float64, Para::Dict) -> 0,\n        SalvageFunction1 = (S1, Para::Dict) -> 0, \n        SalvageFunction2 = (S2, Para::Dict) -> 0)\n\nThis function solves the two-stage optimal control problem defined by the functions\n    - ObjectiveIntegrand1 -> integrand of the objective function\n    - AggregationIntegrand -> integrand of the second stage aggregation function quantile\n    - StateDynamic1 -> State dynamics in the first stage\n    - StateDynamic2 -> State dynamics in the second stage\n    - Shock12 -> function describing the transition of state variables from the first to second stage\n    - SalvageFunction1 -> Salvage function in the first stage\n    - SalvageFunction2 -> Salvage function in the second stage\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/#Parameters,-Variables-and-Settings","page":"Parameters, Variables, Settings","title":"Parameters, Variables and Settings","text":"","category":"section"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersBasics","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersBasics","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersBasics","text":"ParametersBasics(Para,UserPara)\n\nInitialize the basic parameters necessary for the model\n\nT -> time horizon of the model\nhstep -> time step between points\nrho -> time discount rate of the model\nnCon -> number of controls in the first stage\nnCon_dist -> number of controls in the second stage\nnStat -> number of state variables in the first stage\nnStat_dist -> number of state variables in the second stage\nProbIndex -> index of state variable describing the auxiliary variables in both stages\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersGrids","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersGrids","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersGrids","text":"ParametersGrids(Para,UserPara)\n\nInitialize the parameters associated with the time grids\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersControls","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersControls","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersControls","text":"ParametersControls(Para,UserPara)\n\nInitialize the parameters associated with the control variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersAlgorithm","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersAlgorithm","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersAlgorithm","text":"ParametersAlgorithm(Para,UserPara)\n\nInitialize the parameters for the optimisation algorithm\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersInitStates","category":"page"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersPlots","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersPlots","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersPlots","text":"ParametersPlots(Para,UserPara)\n\nInitialize parameters relevant for plotting\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.InitVariables","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.InitVariables","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.InitVariables","text":"InitVariables(Para::Dict)\n\nInitialize control, state and costate variables for the Parameters specified\n\n\n\n\n\n","category":"function"}]
}
