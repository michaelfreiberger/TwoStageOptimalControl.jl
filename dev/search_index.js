var documenterSearchIndex = {"docs":
[{"location":"Examples/Test2/","page":"-","title":"-","text":"using TwoStageOptimalControl","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"U(Con, Stat, t::Float64, Para::Dict) = Stat[2] * ((Para[\"A\"] - Stat[1])Stat[1] - Para[\"b\"]Con[1] - Para[\"c\"]/2Con[1]^2) Q(Con,Stat, t::Float64,s::Float64, Para::Dict) = Stat[2] * ((Para[\"A\"] - Stat[1])Stat[1] - Para[\"b\"]Con[1] - Para[\"c\"]/2Con[1]^2)","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"f1(Con,Stat, t::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]Stat[1],                                         -Para[\"eta\"]Stat[2]] f2(Con,Stat, t::Float64, s::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]*Stat[1],                                                     0]","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"g(Con,Stat,t::Float64, Para::Dict) = [Stat[1],                                       Para[\"eta\"]*Stat[2]]","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"S1(Stat, Para::Dict) = 0 S2(Stat_dist, Para::Dict) = 0","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"MyPara = Dict() MyPara[\"A\"] = 60 MyPara[\"b\"] = 100 MyPara[\"c\"] = 10 MyPara[\"delta\"] = 0.1 MyPara[\"rho\"] = 0.1 MyPara[\"eta\"] = 0.05","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"MyPara[\"T\"] = 10 MyPara[\"hstep\"] = 0.5 MyPara[\"nCon\"] = 1 MyPara[\"nCondist\"] = 1 MyPara[\"nStat\"] = 2 MyPara[\"nStatdist\"] = 2 MyPara[\"InitStat\"] = [0.1,1.0] MyPara[\"ConMin\"] = [0.0] MyPara[\"Con_distMin\"] = [0.0]","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"MyPara[\"OptiType\"] = \"Newton-Raphson\" MyPara[\"ProbIndex\"] = 2","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"MyPara[\"InitLineStep\"] = 1e-5 MyPara[\"UpperLineStep\"] = 1e-2 MyPara[\"hLowBound\"] = 0.1 MyPara[\"PlotResultsIntermediateFrequency\"] = 150","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"MyPara[\"LoadInits\"] = true","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"Results = Dict() Results[\"Con\"] = 6.0ones(1,10,1) Results[\"Con_dist\"] = 6.0ones(10,10,1) Results = TwoStageOptimisation(Results = Results,UserParameters = MyPara,                                 ObjectiveIntegrand = U,                                  AggregationFunction = Q,                                 StateDynamic1 = f1,                                 StateDynamic2 = f2,                                  Shock = g,                                 SalvageFunction1=S1,                                 SalvageFunction2=S2)","category":"page"},{"location":"Examples/Test2/","page":"-","title":"-","text":"SaveResults(Results,\"test/CapitalAccumulationBenchmark\")","category":"page"},{"location":"Functions/ParametersVariablesSettings/#Parameters,-Variables-and-Settings","page":"Parameters, Variables, Settings","title":"Parameters, Variables and Settings","text":"","category":"section"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersBasics","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersBasics","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersBasics","text":"ParametersBasics(Para,UserPara)\n\nInitialize the basic parameters necessary for the model\n\nT           -> time horizon of the model\nhstep       -> time step between points\nrho         -> time discount rate of the model\nnCon        -> number of controls in the first stage\nnCon_dist   -> number of controls in the second stage\nnStat       -> number of state variables in the first stage\nnStat_dist  -> number of state variables in the second stage\nProbIndex   -> index of state variable describing the auxiliary variables in both stages\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersGrids","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersGrids","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersGrids","text":"ParametersGrids(Para,UserPara)\n\nInitialize the parameters associated with the time grids\n\nnTime -> Number of gridpoints along time\nnAge  -> Number of gridpoints along the vintages\ntmesh -> Grid for time\namesh -> Grid for vintages\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersControls","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersControls","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersControls","text":"ParametersControls(Para,UserPara)\n\nInitialize the parameters associated with the control variables\n\nLoadInits   -> Loading specific initial guesses for the control variables\nReduce1     -> Indices of controls, which should be disabled (Stage 1)\nReduce2     -> Indices of controls, which should be disabled (Stage 2)\nConMin      -> Lower bound for the concentated control variables\nConMax      -> Upper bound for the concentated control variables\nCon_distMin -> Lower bound for the distributed control variables\nCon_distMax -> Upper bound for the distributed control variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersAlgorithm","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersAlgorithm","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersAlgorithm","text":"ParametersAlgorithm(Para,UserPara)\n\nInitialize the parameters for the optimisation algorithm\n\nOptiType -> Adjustment of gradient of Hamiltonian\n\"Gradient\" uses the standard gradient of the hamiltonian \n\"ProbAdjust\" scales the gradient by the inverse of the auxiliary variables\n\"Newton-Raphson\" scales the gradient by the inverse of the Hessian\nIntegrationOrder -> Which order should the method of integration used should have.\n4 is the default using Simpson's rule\n2 is another option using the trapezoid rule\nParallelComputing   -> Indicator whether calculations along vintages should be parallised.                        Needs to be implemented in the future.\nhLowBound           -> Lower bound for the step of the gridsize along time.                       hstep gets halfed until the new value falls below hLowBound.\nInitLineStep        -> Initial step-size for the adjustment of control variables along the gradient.\nLineSearchStepIncrease -> Factor for increase in the linesearch stepsize.\nUpperLineStep       -> Upper bound for linesearch stepsize.\nstepLowBound        -> Lower bound for step in gradient search -> termination if undercut.\nGradBound           -> Lower bound for the gradient.                        Algorithm stops if maximum of the absolute value of the gradient is smaller.\nMaxOptiIter         -> Max iterations with same step-size h.\nMaxLineIter         -> Max iterations along the same gradient. \nGradSmooth          -> Indicator if gradients are smoothed.\nConSmooth           -> Indicator if controls are smoothed. \nSearchDISP          -> Indicator if intermediate results of the search along the gradient shall be displayed.\nLineIter            -> Iteration counter\nOptiIter            -> Iteration counter\nHstepIter           -> Iteration counter\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersInitStates","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersInitStates","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersInitStates","text":"ParametersInitStates(Para,UserPara)\n\nInitialize initial and boundary data\n\nInitStat        -> Initial state values of concentated variables\nInitStatdist   -> Initial state values of distributed variables at t=t0                  Will be used in future generalised version of the package\nBoundStat_dist  -> Initial state values of distributed variables at t                  Will be used in future generalised version of the package\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.ParametersPlots","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.ParametersPlots","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.ParametersPlots","text":"ParametersPlots(Para,UserPara)\n\nInitialize parameters relevant for plotting\n\nnVintagePlot            -> Number of vintages plotted for realtime solutions\nPlotResultsStart        -> Indicator for plot of initial guess\nPlotResultsIntermediate -> Indicator for plot of intermediate results\nPlotResultsFinal        -> Indicator for plot of final results\nPlotResultsIntermediateFrequency -> Number of algorithm iterations                                   between plot of Intermediate results\nPlotResultsWaitForKey   -> Indicator whether user input of any key should be necessary                           after plot of intermediate results\nSavePlot                -> Indicator whether plotted results should be saved\nSavePlotPath            -> Path for saved plots\nControlLabelsLatex      -> concentated control labels using latex strings \nControlLabelsSimple     -> concentated control labels without latex strings\nControlDistLabelsLatex  -> distributed control labels using latex strings \nControlDistLabelsSimple -> distributed control labels without latex strings \nStateLabelsLatex        -> concentated state labels using latex strings \nStateLabelsSimple       -> concentated state labels without latex strings \nStateDistLabelsLatex    -> distributed state labels using latex strings \nStateDistLabelsSimple   -> distributed state labels without latex strings \nCoStateLabelsLatex      -> concentated costate labels using latex strings \nCoStateLabelsSimple     -> concentated costate labels without latex strings \nCoStateDistLabelsLatex  -> distributed costate labels using latex strings \nCoStateDistLabelsSimple -> distributed costate labels without latex strings\n\n\n\n\n\n","category":"function"},{"location":"Functions/ParametersVariablesSettings/","page":"Parameters, Variables, Settings","title":"Parameters, Variables, Settings","text":"TwoStageOptimalControl.InitVariables","category":"page"},{"location":"Functions/ParametersVariablesSettings/#TwoStageOptimalControl.InitVariables","page":"Parameters, Variables, Settings","title":"TwoStageOptimalControl.InitVariables","text":"InitVariables(Para::Dict)\n\nInitialize control, state and costate variables for the parameters specified\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.AssignResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.AssignResults","page":"Results analysis","title":"TwoStageOptimalControl.AssignResults","text":"AssignResults(Results::Dict, \n              Con::Array{Float64,3}, \n              Stat::Array{Float64,3}, \n              Con_dist::Array{Float64,3}, \n              Stat_dist::Array{Float64,3}, \n              Stat_agg::Array{Float64,3}, \n              CoStat::Array{Float64,3}, \n              CoStat_dist::Array{Float64,3}, \n              dHam::Array{Float64,3}, \n              dHam_dist::Array{Float64,3}, \n              Para::Dict)\n\nAssign the control and state variables to the Results dictionary\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.PlotResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.PlotResults","page":"Results analysis","title":"TwoStageOptimalControl.PlotResults","text":"PlotResults(Results2::Dict;\n            SavePlot=false,\n            Display=true,\n            sizeX=600,sizeY=400)\n\nBasic plots of all controls + gradient and state + costate variables\n\nSavePlot -> Indicator whether plots should be saved to location specifice in Para[\"SavePlotPath\"]\nDisplay  -> Should the plots be displayed or supressed.\nsizeX, sizeY -> dimensions of the plots. Default = 600x400\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.SaveResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.SaveResults","page":"Results analysis","title":"TwoStageOptimalControl.SaveResults","text":"SaveResults(Results::Dict,filepath)\n\nSave the Results Dictionary to filepath\n\n\n\n\n\n","category":"function"},{"location":"Functions/ResultsHandling/","page":"Results analysis","title":"Results analysis","text":"TwoStageOptimalControl.LoadResults","category":"page"},{"location":"Functions/ResultsHandling/#TwoStageOptimalControl.LoadResults","page":"Results analysis","title":"TwoStageOptimalControl.LoadResults","text":"LoadResults(filepath)\n\nLoad the Results Dictionary from the filepath\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.state_PDE_solver","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.state_PDE_solver","page":"State Solvers","title":"TwoStageOptimalControl.state_PDE_solver","text":"state_PDE_solver(Con::Array{Float64,3},\n                 Stat::Array{Float64,3},\n                 Con_dist::Array{Float64,3},\n                 Stat_dist::Array{Float64,3},\n                 Stat_agg::Array{Float64,3},\n                 Para::Dict)\n\nstate_PDE_solver solves the dynamic system of state equations with given initial conditions and control variables.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.HeunODE","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunODE","page":"State Solvers","title":"TwoStageOptimalControl.HeunODE","text":"HeunODE(Con::Array{Float64,3},Stat::Array{Float64,3},Para::Dict)\n\nHeunODEco solves the state dynamics in the first stage forward in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.RK4ODE","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.RK4ODE","page":"State Solvers","title":"TwoStageOptimalControl.RK4ODE","text":"RK4ODE(Con::Array{Float64,3},Stat::Array{Float64,3},Para::Dict)\n\nRK4ODE solves the state dynamics in the first stage forward in time using a 4th-order Runge-Kutta method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.HeunPDE","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunPDE","page":"State Solvers","title":"TwoStageOptimalControl.HeunPDE","text":"HeunPDE(jj,Con_dist::Array{Float64,3},Stat_dist::Array{Float64,3},Para::Dict)\n\nHeunODEco solves the state dynamics for vintage jj in the second stage forward in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.costate_PDE_solver","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.costate_PDE_solver","page":"State Solvers","title":"TwoStageOptimalControl.costate_PDE_solver","text":"costate_PDE_solver(Con::Array{Float64,3},\n                   Stat::Array{Float64,3},\n                   Con_dist::Array{Float64,3},\n                   Stat_dist::Array{Float64,3},\n                   Stat_agg::Array{Float64,3},\n                   CoStat::Array{Float64,3},\n                   CoStat_dist::Array{Float64,3},\n                   CoStat_agg::Array{Float64,3},\n                   Para::Dict)\n\ncostate_PDE_solver solves the dynamic system of co-state equations backwards with given endvalues for given controls and state variables. For the special case of endconstraints for the STATE-variables, we use the FOC to derive the respective value of CO-STATE variable.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.HeunODEco","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunODEco","page":"State Solvers","title":"TwoStageOptimalControl.HeunODEco","text":"HeunODEco(Con::Array{Float64,3},\n          Stat::Array{Float64,3},\n          CoStat::Array{Float64,3},\n          CoStat_dist::Array{Float64,3},\n          Para::Dict)\n\nHeunODEco solves the costate dynamics in the first stage backwards in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/StateSolvers/","page":"State Solvers","title":"State Solvers","text":"TwoStageOptimalControl.HeunPDEco","category":"page"},{"location":"Functions/StateSolvers/#TwoStageOptimalControl.HeunPDEco","page":"State Solvers","title":"TwoStageOptimalControl.HeunPDEco","text":"HeunPDEco(jj,\n          Con_dist::Array{Float64,3},\n          Stat_dist::Array{Float64,3},\n          CoStat_dist::Array{Float64,3},\n          Para::Dict)\n\nHeunPDEco solves the costate dynamic for vintage jj in the second stage backwards in time using the Heun-method for ordinary differential equations.\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/#LineSearch","page":"LineSearch","title":"LineSearch","text":"","category":"section"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.LineSearch","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.LineSearch","page":"LineSearch","title":"TwoStageOptimalControl.LineSearch","text":"LineSearch(Con::Array{Float64,3}, \n           Stat::Array{Float64,3}, \n           Con_dist::Array{Float64,3},  \n           Stat_dist::Array{Float64,3}, \n           Stat_agg::Array{Float64,3}, \n           Dir_u::Array{Float64,3}, \n           Dir_u_dist::Array{Float64,3}, \n           ObjValue::Float64, \n           Step, \n           Para::Dict,\n           Con_new::Array{Float64,3}, \n           Stat_new::Array{Float64,3}, \n           Con_dist_new::Array{Float64,3}, \n           Stat_dist_new::Array{Float64,3}, \n           Stat_agg_new::Array{Float64,3},\n           Con_best::Array{Float64,3}, \n           Stat_best::Array{Float64,3}, \n           Con_dist_best::Array{Float64,3}, \n           Stat_dist_best::Array{Float64,3}, \n           Stat_agg_best::Array{Float64,3})\n\nSearches for an improvement along the gradient using a quadratic approximation for the objective function along the gradient.\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.Update","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.Update","page":"LineSearch","title":"TwoStageOptimalControl.Update","text":"Update(Con::Array{Float64,3},\n       Con_dist::Array{Float64,3},\n       Dir_u::Array{Float64,3},\n       Dir_u_dist::Array{Float64,3},\n       Step,\n       Para::Dict,\n       Con_new::Array{Float64,3},\n       Stat_new::Array{Float64,3},\n       Con_dist_new::Array{Float64,3},\n       Stat_dist_new::Array{Float64,3}, \n       Stat_agg_new::Array{Float64,3})\n\nUpdate calculates the new values for Controls Con_new, States Stat_new and Objectiv value given start values for the Controls Con, the search direction Dir_u and the step-size in the direction step\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.AssignBest","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.AssignBest","page":"LineSearch","title":"TwoStageOptimalControl.AssignBest","text":"AssignBest(ObjValue::Float64,\n           Con::Array{Float64,3},\n           Stat::Array{Float64,3},\n           Con_dist::Array{Float64,3},\n           Stat_dist::Array{Float64,3}, \n           Stat_agg::Array{Float64,3}, \n           step, \n           Con_best::Array{Float64,3}, \n           Stat_best::Array{Float64,3}, \n           Con_dist_best::Array{Float64,3},  \n           Stat_dist_best::Array{Float64,3},  \n           Stat_agg_best::Array{Float64,3})\n\nAssign the current variables to the \"best\" variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/LineSearch/","page":"LineSearch","title":"LineSearch","text":"TwoStageOptimalControl.maxabsGradient","category":"page"},{"location":"Functions/LineSearch/#TwoStageOptimalControl.maxabsGradient","page":"LineSearch","title":"TwoStageOptimalControl.maxabsGradient","text":"maxabsGradient(Con::Array{Float64,3},\n               Con_dist::Array{Float64,3},\n               dHam::Array{Float64,3},\n               dHam_dist::Array{Float64,3},\n               Para::Dict)\n\nCalculate the maximum of the absolute value of the gradient of the Hamiltonian accounting for controls which are on the boundary of their feasible regions.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ObjectValue","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ObjectValue","page":"Model Functions","title":"TwoStageOptimalControl.ObjectValue","text":"ObjectValue( Con::Array{Float64,3}, \n             Stat::Array{Float64,3}, \n             Con_dist::Array{Float64,3}, \n             Stat_dist::Array{Float64,3},  \n             Stat_agg::Array{Float64,3}, \n             Para::Dict )\n\nCalculate the aggregated objective value of the optimal control problem for the current solutions of control and state variables\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.Aggregate","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.Aggregate","page":"Model Functions","title":"TwoStageOptimalControl.Aggregate","text":"Aggregate(Con_dist::Array{Float64,3},\n          Stat_dist::Array{Float64,3},\n          Stat_agg::Array{Float64,3},\n          Para::Dict )\n\nCalculate the aggregated variables over all vintage in the second stage\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ShockTransition","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ShockTransition","page":"Model Functions","title":"TwoStageOptimalControl.ShockTransition","text":"ShockTransition(Con::Array{Float64,3},\n                Stat::Array{Float64,3},\n                Stat_dist::Array{Float64,3},\n                Para::Dict )\n\nCalculate the starting values for all vintages given the state profiles of the first stage.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_ODE","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_ODE","page":"Model Functions","title":"TwoStageOptimalControl.f_ODE","text":"f_ODE( tt::Int64, \n       Con::Array{Float64,3}, \n       Stat::Array{Float64,3}, \n       Dt::Array{Float64,1}, \n       Para::Dict )\n\nRight hand side of the ODE for the state variables in the first stage at time index tt.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_ODE_interstep","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_ODE_interstep","page":"Model Functions","title":"TwoStageOptimalControl.f_ODE_interstep","text":"f_ODE_interstep( t::Float64, Con, Stat, Para::Dict)\n\nRight hand side of the ODE for the state variables in the first stage. Only used for the 4th order RK-method where the Control variables have to be interpolated.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_PDE","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_PDE","page":"Model Functions","title":"TwoStageOptimalControl.f_PDE","text":"f_PDE( tt::Int64, ss::Int64, \n       Con_dist::Array{Float64,3}, \n       Stat_dist::Array{Float64,3}, \n       Dt::Array{Float64,1},\n       Para::Dict )\n\nRight hand side of the PDE for the state variables in the second stage at time index tt and vintage ss.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_ODE_co","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_ODE_co","page":"Model Functions","title":"TwoStageOptimalControl.f_ODE_co","text":"f_ODE_co( tt::Int64,\n          Con::Array{Float64,3},\n          Stat::Array{Float64,3},\n          CoStat::Array{Float64,3},\n          CoStat_dist::Array{Float64,3},\n          Dt::Array{Float64,1},\n          Para::Dict )\n\nRight hand side of the PDE for the costate variables in the first stage at time index tt.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.f_PDE_co","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.f_PDE_co","page":"Model Functions","title":"TwoStageOptimalControl.f_PDE_co","text":"f_PDE_co( tt::Int64, ss::Int64,\n          Con_dist::Array{Float64,3},\n          Stat_dist::Array{Float64,3},\n          CoStat_dist::Array{Float64,3},\n          Dt::Array{Float64,1},\n          Para::Dict )\n\nRight hand side of the PDE for the costate variables in the second stage at time index tt and vintage ss.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.Hamiltonian","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.Hamiltonian","page":"Model Functions","title":"TwoStageOptimalControl.Hamiltonian","text":"Hamiltonian(Con, Stat, CoStat, CoStat_dist, \n            t::Float64, Para::Dict )\n\nDefinition of the Hamiltonian with all terms relevant for the calculations including first stage variables.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.Hamiltonian_dist","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.Hamiltonian_dist","page":"Model Functions","title":"TwoStageOptimalControl.Hamiltonian_dist","text":"Hamiltonian_dist(Con_dist, \n                 Stat_dist, \n                 CoStat_dist, \n                 t::Float64, \n                 s::Float64, \n                 Para::Dict )\n\nDefinition of the Hamiltonian with all terms relevant for the calculations including second stage variables.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.GradHamiltonian","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.GradHamiltonian","page":"Model Functions","title":"TwoStageOptimalControl.GradHamiltonian","text":"GradHamiltonian(Con::Array{Float64,3},\n                Stat::Array{Float64,3},\n                Con_dist::Array{Float64,3},\n                Stat_dist::Array{Float64,3},\n                Stat_agg::Array{Float64,3},\n                CoStat::Array{Float64,3},\n                CoStat_dist::Array{Float64,3},\n                dHam::Array{Float64,3},\n                dHam_dist::Array{Float64,3},\n                Para::Dict)\n\nCalculation of the gradient of the Hamiltonian for both stages.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.NewDirection","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.NewDirection","page":"Model Functions","title":"TwoStageOptimalControl.NewDirection","text":"NewDirection(Con::Array{Float64,3},\n             Stat::Array{Float64,3},\n             Con_dist::Array{Float64,3},\n             Stat_dist::Array{Float64,3},\n             Stat_agg::Array{Float64,3},\n             CoStat::Array{Float64,3},\n             CoStat_dist::Array{Float64,3},\n             dHam::Array{Float64,3},\n             dHam_dist::Array{Float64,3},\n             Para::Dict)\n\nAdjustment of the gradient of the Hamiltonian depending on the optimisation type chosen. Available types are:\n\n\"Gradient\" -> Uses the gradient without adjustments\n\"ProbAdjust\" -> Adjusts the gradient for the weighting of the vintage in the second stage and the survival probability in the first stage\n\"Newton-Raphson\" -> Adjusts the gradient as described in the Newton-Raphson method using the Hessian of the Hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ConMapping","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ConMapping","page":"Model Functions","title":"TwoStageOptimalControl.ConMapping","text":"ConMapping( Con::Array{Float64,3}, Para )\n\nMap control variables in the first stage into the feasible region described by the lower and upper bounds of the controls.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.ConMapping_dist","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.ConMapping_dist","page":"Model Functions","title":"TwoStageOptimalControl.ConMapping_dist","text":"ConMapping_dist( Con_dist::Array{Float64,3}, ii, Para )\n\nMap control variables in the second stage into the feasible region described by the lower and upper bounds of the controls.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.EndConstraintCoStat","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.EndConstraintCoStat","page":"Model Functions","title":"TwoStageOptimalControl.EndConstraintCoStat","text":"EndConstraintCoStat(Stat::Array{Float64,3}, CoStat::Array{Float64,3}, Para::Dict)\n\nDefine the endconstraint for the first stage costate variables using the derivative of the salvage-function.\n\n\n\n\n\n","category":"function"},{"location":"Functions/ModelFunctions/","page":"Model Functions","title":"Model Functions","text":"TwoStageOptimalControl.EndConstraintCoStat_dist","category":"page"},{"location":"Functions/ModelFunctions/#TwoStageOptimalControl.EndConstraintCoStat_dist","page":"Model Functions","title":"TwoStageOptimalControl.EndConstraintCoStat_dist","text":"EndConstraintCoStat_dist(Stat_dist::Array{Float64,3}, CoStat_dist::Array{Float64,3}, Para::Dict)\n\nDefine the endconstraint for the second stage costate variables using the derivative of the salvage-function.\n\n\n\n\n\n","category":"function"},{"location":"Examples/Test1/#Capital-accumulation-problem","page":"Example 1","title":"Capital accumulation problem","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Consider the following capital accumulation problem, where a stochastic shock destroys are certain share of the production capital. The problem consists of the following variables:","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Production capital K_1(t) before the shock (first stage), K_2(ts) after the shock at time s (second stage).\nInvestment in production capital in the first, I_1(t), and second, I_2(ts), stage.\nConsumption c_1(t) and c_2(ts) in the first and second stage. Consumption is thereby the residual of production minus the cost for investment in production capital (which is assumed to be quadratic)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"beginaligned\nc_1(t) = K_1(t)^05 - I_1(t)^2 \nc_2(ts) = K_2(ts)^05 - I_2(ts)^2\nendaligned","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"The shock has an arrival rate of eta with the time horizon being scaled down to T=10. At the point of the shock, we assume a share gamma of production capital is being destroyed.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"The social planer now maximizes the aggregated consumption over the whole time horizon. The whole problem writes as follows:","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"beginaligned\nmax_I_1(t)I_2(ts) int_0^T e^rho tcdotleft Z_1(t)cdot Big K_1(t)^05 - I_1(t)^2Big + Q(t) right dt \nsthspace1cm dotK_1(t) = I_1(t) - delta K_1(t) qquad K_1(0) = K_1^0 \ndotZ_1(t) = - etacdot Z_1(t)                      qquad Z_1(0) = 1 \ndotK_2(ts) = I_2(ts) - delta K_2(ts)            qquad K_2(ss) = (1-gamma)cdot K_1(s) \ndotZ_2(ts) = 0                                     qquad Z_2(ss) = etacdot Z_1(s) \nQ(t) = int_0^t Z_2(ts)cdot Big K_2(ts)^05 - I_2(ts)^2Big ds\nendaligned","category":"page"},{"location":"Examples/Test1/#Solution-in-Julia","page":"Example 1","title":"Solution in Julia","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"To solve this problem with our Toolbox, we can use the main function TwoStageOptimisation.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> Results = TwoStageOptimisation(UserParameters = MyPara,\n                                ObjectiveIntegrand = U, \n                                AggregationFunction = Q,\n                                StateDynamic_1 = f1,\n                                StateDynamic_2 = f2, \n                                Shock = g,\n                                SalvageFunction_1=S1,\n                                SalvageFunction_2=S2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"But first we need to define the functions U, Q, f1, f2, g, S1 and S2 as well as the dictionary MyPara.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Let us start with the dictionary.","category":"page"},{"location":"Examples/Test1/#MyPara","page":"Example 1","title":"MyPara","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"The dictionary MyPara contains all relevant parameters of the model. We can initialize an empty dictionary by","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara = Dict()","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"MyPara contains information on","category":"page"},{"location":"Examples/Test1/#Model-specific-parameters","page":"Example 1","title":"Model specific parameters","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"like rho, eta and gamma in this example;","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"T\"] = 1\njulia> MyPara[\"rho\"] = 0.05\njulia> MyPara[\"delta\"] = 0.1\njulia> MyPara[\"eta\"] = 0.5\njulia> MyPara[\"gamma\"] = 0.2","category":"page"},{"location":"Examples/Test1/#Model-dimensions-of-controls-and-states","page":"Example 1","title":"Model dimensions of controls and states","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"nCon is the number of control variables in the first stage, nCon_dist is the number of control variables in the second stage. nStat and nStat_dist are the dimensions of state variables before and after the shock.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"nCon\"] = 1\njulia> MyPara[\"nCon_dist\"] = 1\njulia> MyPara[\"nStat\"] = 2\njulia> MyPara[\"nStat_dist\"] = 2","category":"page"},{"location":"Examples/Test1/#Control-boundaries-and-initial-state-values","page":"Example 1","title":"Control boundaries and initial state values","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"ConMin\"] = [0.0]\njulia> MyPara[\"Con_distMin\"] = [0.0]\njulia> MyPara[\"InitStat\"] = [0.1,1.0]","category":"page"},{"location":"Examples/Test1/#Algorithm-specifying-parameters","page":"Example 1","title":"Algorithm specifying parameters","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"hstep\"] = 0.05\njulia> MyPara[\"InitLineStep\"] = 1e-5\njulia> MyPara[\"UpperLineStep\"] = 1e-1\njulia> MyPara[\"hLowBound\"] = 0.01\njulia> MyPara[\"PlotResultsIntermediateFrequency\"] = 30","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Information on the parameters base values, which are used if not specified differently, can be found in the section Parameters, Variables, Settings","category":"page"},{"location":"Examples/Test1/#Model-functions","page":"Example 1","title":"Model functions","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Now we need to specify all the functions used in the model. Any function, that is not defined is assumed to be the zero-function.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"U(Con, Stat, t::Float64, Para::Dict) covers the utility function in the first stage (without the aggregated part Q(t) of the second stage). In our example this is ","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> U(Con, Stat, t::Float64, Para::Dict) = Stat[2]*(Stat[1]^0.5 - Con[1]^2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Q(Con,Stat, t::Float64,s::Float64, Para::Dict) contains the function which is integrated to obtain the second stage utiltiy.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> Q(Con,Stat, t::Float64,s::Float64, Para::Dict) = Stat[2]*(Stat[1]^0.5 - Con[1]^2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"f1(Con,Stat, t::Float64, Para::Dict) and f2(Con,Stat, t::Float64, s::Float64, Para::Dict) are the function of the right hand side of the state dynamics.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> f1(Con,Stat, t::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]*Stat[1],-Para[\"eta\"]*Stat[2]]\njulia> f2(Con,Stat, t::Float64, s::Float64, Para::Dict) = [Con[1] - Para[\"delta\"]*Stat[1], 0]","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"g(Con,Stat,t::Float64, Para::Dict) describes the transition function between the state variables in the two stages.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> g(Con,Stat,t::Float64, Para::Dict) = [(1-Para[\"gamma\"])*Stat[1],Para[\"eta\"]*Stat[2]]","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"S1(Stat, Para::Dict) and S2(Stat_dist, Para::Dict) are the salvage-function in the first and second stage. Since we have no salvage value in our toy-example, we could omit them as entries in TwoStageOptimisation. However, we can also specifiy and enter them.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> S1(Stat, Para::Dict) = 0\njulia> S2(Stat_dist, Para::Dict) = 0","category":"page"},{"location":"Examples/Test1/#Solve-the-model","page":"Example 1","title":"Solve the model","text":"","category":"section"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Finally we can solve the model. But first, we specify, that we want to give the initial guess for the control profiles to the algorithm","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> MyPara[\"LoadInits\"] = true","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Now we define the profiles. We can pick the dimensions across time how big we like, the controls get interpolated in the solution process. Here we decided for 100 points. We define the control profiles as entries in the Results dictionary.","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> Results = Dict()\njulia> Results[\"Con\"] = 4.0*ones(1,100,1)\njulia> Results[\"Con_dist\"] = 4.0*ones(100,100,1)\njulia> Results = TwoStageOptimisation(Results = Results,UserParameters = MyPara,\n                                ObjectiveIntegrand1 = U, \n                                AggregationIntegrand2 = Q,\n                                StateDynamic1 = f1,\n                                StateDynamic2 = f2, \n                                Shock12 = g,\n                                SalvageFunction1=S1,\n                                SalvageFunction2=S2)","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"Finally we can save the results in location of choice and also plot the final results. We have the option to save the plots, and they are automatically save","category":"page"},{"location":"Examples/Test1/","page":"Example 1","title":"Example 1","text":"julia> SaveResults(Results,\"CapitalAccumulation\")\njulia> PlotResults(Results,SavePlot = true)","category":"page"},{"location":"#TwoStageOptimalControl","page":"Home","title":"TwoStageOptimalControl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For general information on the package, the model class it is able to solve, and how to install it, please revisit the ReadMe page.","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following subsections are structured identical to the position of function definitions in the source code and should also act as an orientation for programmers trying to adapt to algorithm for their specific needs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The most important functions for simple usage are contained in the following three subsections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main function for usage: This section contains the function TwoStageOptimisation, which is used to solve a given problem. For examples on how to use it, see example 1 and example 2.\nParameters, Variables, Settings: In this section all parameters and settings for the solution algorithm are described.\nResults Handling: In this section all functions are summarised which concern saving, loading and plotting of results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The remaining subsections contains the documentation for functions used within the solution algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Auxiliary functions: This section contains functions which are not algorithm specific like integration and smoothing functions.\nLineSearch: This section contains the functions describing the linesearch along the gradient leading to the new guess for the control profiles.\nModel Functions: In this section the functions provided by the user are used to define all internal model functions like the Hamiltonian and all equations like the costate dynamics and gradients, which are derived from it.\nState solvers: In this section all functions for the solution of the state and costate differential equation are defined.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As an example often says more then 1000 explanations, please find two examples for the usage of the toolbox below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example 1\nExample 2","category":"page"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.integ4","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.integ4","page":"Auxiliary functions","title":"TwoStageOptimalControl.integ4","text":"integ4(n::Int64, h::Float64, F)\n\ninteg4 performs 4th order integration (Simpson-method) method for datavector F with n points with a distance of h between each of them. If n > 1 and F = 1, F will be interpreted as a constant function over the n points.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.integ2","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.integ2","page":"Auxiliary functions","title":"TwoStageOptimalControl.integ2","text":"integ2(n::Int64, h::Float64, F)\n\ninteg2 performs 2nd order integration (trapezoid) method for datavector F with n points with a distance of h between each of them. If n > 1 and F = 1, F will be interpreted as a constant function over the n points.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.integ1","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.integ1","page":"Auxiliary functions","title":"TwoStageOptimalControl.integ1","text":"integ1(n::Int64, h::Float64, F)\n\ninteg1 performs 1st order left boundary integration method for datavector F with n points with a distance of h between each of them. If n > 1 and F = 1, F will be interpreted as a constant function over the n points.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.CumInteg4","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.CumInteg4","page":"Auxiliary functions","title":"TwoStageOptimalControl.CumInteg4","text":"CumInteg4(n::Int64, h::Float64, F)\n\nCumInteg4 calculates the cumulative integrals \n\nint_0^t F(s)ds forall tin(0T)\n\nof F using a 4th order integration method.\n\nn -> number of datapoints,\nh -> distance between datapoints.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.interp1","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.interp1","page":"Auxiliary functions","title":"TwoStageOptimalControl.interp1","text":"interp1(xpt, ypt; method = \"Linear\", extrapolation = Flat())\n\nOne dimensional interpolation using either linear interpolation or BSplines\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.interp2","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.interp2","page":"Auxiliary functions","title":"TwoStageOptimalControl.interp2","text":"interp2(xpt,ypt,zpt)\n\nTwo dimensional interpolation using BSplines\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.SavitskyGolaySmoothing","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.SavitskyGolaySmoothing","page":"Auxiliary functions","title":"TwoStageOptimalControl.SavitskyGolaySmoothing","text":"SavitskyGolaySmoothing(x::Vector, windowSize::Integer, polyOrder::Integer; deriv::Integer=0)\n\nSmooth a vector x using the Savitsky-Golay method\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.ParaAdjust","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.ParaAdjust","page":"Auxiliary functions","title":"TwoStageOptimalControl.ParaAdjust","text":"ParaAdjust(h_global::Float64, Para::Dict)\n\nParaAdjust adjust all relevant elements of the Parameter dictionary Para to the step-size h_global.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.LoadVariables","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.LoadVariables","page":"Auxiliary functions","title":"TwoStageOptimalControl.LoadVariables","text":"LoadVariables(Para, Results)\n\nLoad inital profiles for the control variables from the Results dictionary and use interpolation if necessary\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.ConInterpol","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.ConInterpol","page":"Auxiliary functions","title":"TwoStageOptimalControl.ConInterpol","text":"ConInterpol(Con_dist::Array{Float64,3}, Con::Array{Float64,3}, Para::Dict)\n\nGiven Controls Con_dist and Con, ConInterpol performs an interpolation of these fields to fit the passed Parameter dict Para.\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.ConSmooth","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.ConSmooth","page":"Auxiliary functions","title":"TwoStageOptimalControl.ConSmooth","text":"ConSmooth(Con::Array{Float64,3}, Con_dist::Array{Float64,3}, Para::Dict)\n\nSmooth the profiles of the control variables using a SavitskyGolaySmoother\n\n\n\n\n\n","category":"function"},{"location":"Functions/AuxiliaryFunction/","page":"Auxiliary functions","title":"Auxiliary functions","text":"TwoStageOptimalControl.GradSmooth","category":"page"},{"location":"Functions/AuxiliaryFunction/#TwoStageOptimalControl.GradSmooth","page":"Auxiliary functions","title":"TwoStageOptimalControl.GradSmooth","text":"GradSmooth(dHam::Array{Float64,3}, dHam_dist::Array{Float64,3}, Para::Dict)\n\nSmooth the gradient by using the median value of a moving window.\n\n\n\n\n\n","category":"function"},{"location":"Functions/MainFunction/#Main-Function","page":"Main Functions","title":"Main Function","text":"","category":"section"},{"location":"Functions/MainFunction/","page":"Main Functions","title":"Main Functions","text":"TwoStageOptimisation","category":"page"},{"location":"Functions/MainFunction/#TwoStageOptimalControl.TwoStageOptimisation","page":"Main Functions","title":"TwoStageOptimalControl.TwoStageOptimisation","text":"TwoStageOptimisation(;Results=Dict(),\n        UserParameters=Dict(),\n        ObjectiveIntegrand1 = (C1, S1, t::Float64, Para::Dict) -> 0,\n        AggregationIntegrand2 = (C2, S2, t::Float64,s::Float64, Para::Dict) -> 0,\n        StateDynamic1 = (C1, S1, t::Float64, Para::Dict) -> 0, \n        StateDynamic2 = (C2, S2, t::Float64, s::Float64, Para::Dict) -> 0, \n        Shock12 = (C1, S1, t::Float64, Para::Dict) -> 0,\n        SalvageFunction1 = (S1, Para::Dict) -> 0, \n        SalvageFunction2 = (S2, Para::Dict) -> 0)\n\nThis function solves the two-stage optimal control problem defined by the functions\n\nObjectiveIntegrand1 -> integrand of the objective function\nAggregationIntegrand -> integrand of the second stage aggregation function quantile\nStateDynamic1 -> State dynamics in the first stage\nStateDynamic2 -> State dynamics in the second stage\nShock12 -> function describing the transition of state variables from the first to second stage\nSalvageFunction1 -> Salvage function in the first stage\nSalvageFunction2 -> Salvage function in the second stage\n\n\n\n\n\n","category":"function"}]
}
